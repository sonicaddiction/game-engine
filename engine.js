// Generated by CoffeeScript 1.6.3
/*
  Tänket är att man har ett visst antal handlingar per rond.
  Man får reda på sitt initiativvärde och kan därefter välja hur man vill spendera sina handlingar.
  Om man får en skada och misslyckas med ett motståndsslag förlorar man resterande handlingar.
  Om man får en skada försämras initiativvärdet inför kommande rond.
  Om man får högre initiativ som blockerare blir blockeringen lättare och det finns en chans för ripost
*/


(function() {
  var Attack, Block, Engine, log, _;

  log = (require('./log')).log;

  Attack = (require('./action')).Attack;

  Block = (require('./action')).Block;

  _ = require("lodash");

  Engine = (function() {
    function Engine() {
      this.agents = [];
      this.actionList = [];
      this.blockList = [];
      this.attackList = [];
    }

    Engine.prototype.addAgent = function(agent) {
      return this.agents.push(agent);
    };

    Engine.prototype.getAgent = function(index) {
      return this.agents[index];
    };

    Engine.prototype.listAgents = function() {
      var agent, index, name, statusEffect, statuses, _i, _len, _ref, _ref1, _results;
      _ref = this.agents;
      _results = [];
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        agent = _ref[index];
        statuses = [];
        _ref1 = agent.statusEffects;
        for (name in _ref1) {
          statusEffect = _ref1[name];
          if (statusEffect.isActive()) {
            statuses.push(statusEffect.name);
          }
        }
        _results.push(log("Agent " + index + ": " + agent.name + ", HP: " + agent.hitpoints + ", Statuses: " + (statuses.join(", "))));
      }
      return _results;
    };

    Engine.prototype.addAction = function(action) {
      action.setPriority(action.performer.skills.initiative.skillCheckDiff());
      this.actionList.push(action);
      return this.actionList = _.sortBy(this.actionList, function(_action) {
        return _action.priority;
      }).reverse();
    };

    Engine.prototype.listActions = function() {
      var action, _i, _len, _ref;
      log("***");
      _ref = this.actionList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        action = _ref[_i];
        log(action.priority + "\t" + action.performer.name + "\t" + action.name);
      }
      return log("***");
    };

    Engine.prototype.hit = function(attack) {
      var attacker, damage, defender, toughEnough;
      attacker = attack.attacker;
      defender = attack.defender;
      damage = attacker.mainWeapon.damage.roll();
      defender.hitpoints -= damage;
      log("" + defender.name + " is hit for " + damage + " hp and has " + defender.hitpoints + " hp left");
      if (defender.hitpoints < 0) {
        defender.setDead();
        log("" + defender.name + " dies from the wounds");
        return;
      }
      toughEnough = defender.skills.toughness.skillCheckVs(damage);
      if (toughEnough) {
        return log("" + defender.name + " just shakes the damage off");
      } else {
        defender.setStunned(1);
        return log("" + defender.name + " takes a bit to much damage and looses remaining actions");
      }
    };

    Engine.prototype.singleBlock = function(attack) {};

    Engine.prototype.attack = function(attack) {
      var attacker, block, defender, successfulAttack, successfulBlock;
      attacker = attack.attacker;
      defender = attack.defender;
      if (attacker.isDead()) {
        log("" + attacker.name + " is dead.");
        return;
      }
      if (defender.isDead()) {
        log("" + defender.name + " is dead.");
        return;
      }
      if (attacker.isStunned()) {
        log("" + attack.attacker.name + " is stunned and can not attack");
        return;
      }
      log("" + attack.attacker.name + " attacks " + attack.defender.name);
      successfulAttack = attacker.getSkillForMainWeapon().skillCheck();
      block = this.popEligibleBlocks(attack);
      if (block && !defender.isStunned()) {
        successfulBlock = defender.getSkillForMainWeapon().skillCheck();
      }
      if (successfulAttack && !successfulBlock) {
        return this.hit(attack);
      } else if (successfulAttack && successfulBlock) {
        return log("" + defender.name + " blocks the attack");
      } else if (successfulBlock && !successfulAttack) {
        return log("" + defender.name + " blocks a failed attack and gains some initiative");
      } else {
        return log("Both " + attacker.name + " and " + defender.name + " stumble around clumsily");
      }
    };

    Engine.prototype.popEligibleBlocks = function(attack) {
      var block,
        _this = this;
      block = _.find(this.blockList, function(block, index) {
        if (block.blocker === attack.defender) {
          _this.blockList.splice(index, 1);
          return true;
        }
      });
      return block;
    };

    Engine.prototype.resolveRound = function() {
      var action, attack, _i, _j, _len, _len1, _ref, _ref1, _results;
      this.listActions();
      _ref = this.actionList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        action = _ref[_i];
        switch (action.name) {
          case 'attack':
            this.attackList.push(action);
            break;
          case 'block':
            this.blockList.push(action);
        }
      }
      _ref1 = this.attackList;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        attack = _ref1[_j];
        _results.push(this.attack(attack));
      }
      return _results;
    };

    Engine.prototype.setupRound = function() {
      var agent, _i, _len, _ref, _results;
      this.actionList = [];
      this.blockList = [];
      this.attackList = [];
      _ref = this.agents;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        agent = _ref[_i];
        _results.push(agent.countDownStatuses());
      }
      return _results;
    };

    return Engine;

  })();

  exports.Engine = Engine;

  exports.Attack = Attack;

  exports.Block = Block;

}).call(this);
